# Поиск множеств «входных» переменных в булевых формулах, заданных в КНФ

## Описание

### Какая задача решается

Поиск множеств «входных» переменных в булевой формуле. Множество «входных» переменных — такое множество переменных, что при
подстановке значений всем переменным множества значения для всех остальных переменных формулы определяются однозначно.
Иногда такие переменные называют ещё «существенными».

### Зачем её решать

Множество входных переменных, если оно известно, может быть использовано для прогнозирования времени работы и распараллеливания
решения задачи SAT для конкретной формулы. Этим занимаются специальные методы декомпозиции по входам.

### Справка и терминология

Задача SAT — Дана булева формула в КНФ. Найти набор значений переменных, при котором формула истинна, или доказать,
что такого назначения не существует.

Задача NP-полна, если она принадлежит классу NP и любая задача из NP сводится к ней за полиномиальное время. Задача SAT NP-полна.

SAT-решатель — программа, решающая задачу SAT.

Процедура распространения единичных литералов (Unit Propagation — UP) — алгоритм, позволяющий упростить формулу, заданную в КНФ.

Основной алгоритм решения SAT — Conflict-Driven Clause Learning (CDCL), базирующийся на алгоритме DPLL (по именам учёных),
в основе которого лежит процедура распространения единичных литералов (UP).

### Использование

Задача SAT применяется во многих областях, в частности, при решении оптимизационных задач или верификации программ и схем.
Верификация сводится к построению булевой модели системы, после чего с помощью решения задачи SAT можно проверить существование
или отсутствие удовлетворяющего означивания переменных, что эквивалентно поиску ошибок в программе или схеме.

Так как задача SAT является NP-полной, SAT-решатель может работать экспоненциально долго (т. н. heavy-tailed behaviour).
С этим можно бороться, применяя параллельность с помощью специальных методов декомпозиции.
Специальные методы построения декомпозиций позволяют декомпозировать задачу на множество независимых подзадач, решаемых параллельно,
а также построить точные оценки времени решения такой декомпозиции. Однако такие методы требуют знания множества «входов».

### Ресурсы

[Презентация по теме](https://drive.google.com/file/d/15zwziUkcqTlDSE9VIPvaaTykMrNnmGb0/view?usp=sharing)

## Подготовка

### Требования

- python $\ge$ 3.9

### Установка

```
git pull --recurse-submodules
cd abc
make
cd ..
cd aiger
./configure.sh && make
cd ..
pip install -r requirements.txt
```

## Структура

### Флоу запуска

Для начала необходимо найти где-то примеры логических схем. Используются ресурсы с соревнований по формальной верификации схем,
они добавлены в репозиторий сабмодулями, на данный момент это [benchmarks](https://github.com/lsils/benchmarks.git) и
[iwls2024-ls-contest](https://github.com/alanminko/iwls2024-ls-contest.git).

Затем необходимо найденные схемы переконвертировать из форматов для схем в формат для булевых формул в КНФ. Этим занимается
[модуль тестов](./create_tests.py). Теоретически поддерживаются два формата для схем — `.aig` и `.blif`, по факту пока что конвертируется только `.aig`.
Общеизвестный функционал конвертации ограничен и не всегда точен, поэтому используется специальная [утилита](https://github.com/Lipen/aigerox).
Она доступна в Test PyPI.

Таким образом, схема из бинарного формата `.aig` конвертируется в ASCII-формат `.aag` с помощью утилиты [aiger](https://github.com/arminbiere/aiger),
затем из `.aag` конвертируется в `.cnf` в общепринятом формате DIMACS с помощью утилиты [aigerox](https://github.com/Lipen/aigerox).
Чтобы исключить ошибки при конвертации, после этого шага формула проверяется SAT-солвером на выполнимость с ограничением по времени в $15$ секунд.
Для схем этого времени должно хватить с запасом, так как их решения обычно тривиальны.
Затем с помощью этой же утилиты из формулы вытаскиваются входы, так как для схем они известны, и все артефакты конвертации сохраняются в [tests](./tests).

После этого тесты готовы, можно запускать решения и проверки. Для запуска решений используется [скрипт](./run-test.sh), чтобы
запустить конкретные решения на конкретных тестах, нужно отредактировать содержимое переменных `solutions` и `skip_tests`.

Затем ответы, найденные решениями, можно оценить и автоматически составить отчёт, этим занимается [модуль отчётов](./report.py).
Отчет сохраняется в [reports](./reports), чтобы не засорять репозиторий, папка игнорируется гитом.

Для сбора статистики по конфликтам в подстановках для различных схем используется [скрипт](./run-hypothesis-large-sets.sh).
В папку [stats](./stats) записываются наблюдения о конфликтах на различных размерах множеств для разных схем.
На этих наблюдениях затем можно построить графики с помощью [графического модуля](./graphics.py).

## Решения

### Переборные решения

- [fullscan_border](./fullscan_border.py): полный перебор всех возможных подмножеств
  в порядке увеличения размера подмножества. На шаге $k$ перебираются все подмножества мощности $k$,
  если найден вход, перебор прекращается. Худший случай, очевидно $\theta(4^n)$.
  ($n$ – количество переменных в формуле), так как $2^n$ возможных подмножеств и в каждом подмножестве
  необходимо перебрать все возможные значения переменных. По факту же если вход совсем небольшой, отработает быстро.
- [fullscan_3n](./fullscan_3n.py): полный перебор за $O(3^n)$. Минус по сравнению с [fullscan_border](./fullscan_border.py) в том, что нет
  отсечения при найденном маленьком размере входа, и время всегда экспоненциальное.
- Остальные переборные решения, как правило, тоже содержат префикс `fullscan`, и являются различными оптимизациями с
  отсечениями. Не стоит обращать на них особенного внимания, так как на реальных размерах схем они всё равно совершенно неэффективны.

### Приближённые решения

- [evolution](./evolution.py): эволюционный алгоритм 1+1, особь — множество переменных, мутация — равновероятная замена каждого
  элемента множества на ещё не используемый, функция приспособленности — конфликты и количество выведенных на некоторых подстановках.
- [cut_conflicts](./cut_conflicts.py): использует функционал SAT-решателя по нахождению конфликтующих переменных.
  Строим большое множество переменных, делаем на нём несколько подстановок, исключаем самую часто конфликтующую переменную,
  повторяем до тех пор, пока не достигнем нужного размера множества.
- [greedy_expansion](./greedy_expansion.py): алгоритм жадного расширения, берём какое-то стартовое множество, пытаемся расширить
  его в сторону тех переменных, которые дают меньше всего конфликтов.
- [orchestra](./orchestra.py): комбинация [greedy_expansion](./greedy_expansion.py) и [evolution](./evolution.py), сначала
  расширяемся в сторону минимальных конфликтов, затем мутируем получившиеся множества.

### Полные решения

- Таких нет, это $NP-NP$ задача.

## Что ещё предстоит сделать

### Приоритеты:
- ${\color{red}Критический}$
- ${\color{blue}Обычный}$
- ${\color{green}Необязательный}$

### ${\color{red}Ускорить \space решение}$

- Сейчас [решение](./orchestra.py), получающее нормальный ответ, для схемы `div` гоняется примерно неделю. 
Надо каким-то образом его ускорить, при этом не сильно ухудшив ответ
- Добавить простую балансировку между временем работы и точностью ответа, желательно вообще одним параметром

### ${\color{red}Внедрить \space решение \space в \space метод \space оценки \space времени \space работы \space SAT-решателя}$

### ${\color{blue}Почистить \space код \space и \space структуру \space репозитория}$

- Удалить неиспользуемые решения
- Разложить все кодовые файлы по отдельным модулям (решения, скрипт для тестов, для проверки, и т. д.)
- Избавиться везде в коде от абсолютных путей до файлов
- Сделать один или несколько простых методов для внешнего использования
- Выложить в PyPI

### ${\color{blue}Написать \space обфускатор \space для \space формул \space схем}$

- Сейчас во всех формулах схем входы — просто первые $n$ чисел, это не очень хорошо, потому что решение может случайно 
завязаться на этот факт так, что будет незаметно. Надо написать программу, получающую на вход схему и её входы и возвращающую 
ту же схему, с теми же входами, но с переменными перенумерованными в случайном порядке

### ${\color{green}Построить \space график \space размера \space схем \space и \space входов}$

- Было бы хорошо наглядно увидеть, как размер входа зависит от размера схемы для реальных схем, представленных в тестах. 
Можно для этого построить какую-нибудь точечную диаграмму, например, или ещё какой-нибудь график

### ${\color{green}Добавить \space больше \space тестов}$

- Существует некоторое множество соревнований по формальной верификации схем, можно взять схемы оттуда, добавить в репозиторий сабмодулем
- Нагенерировать или взять с соревнований SAT-решателей обычные формулы, не обязательно полученные из схем

### ${\color{green}Улучшить \space парсинг \space тестов, \space порефакторить \space модуль, \space этим \space занимающийся}$

- Стоит сделать полное флоу примерно такого вида: при наличии AIG-файла парсим его, результат проверяем на SAT. 
Если UNSAT или AIG-файла нет, то парсим BLIF, снова проверяем на SAT. Если опять UNSAT или BLIF-файла нет, то забиваем на этот тест.
- Добавить в модуль тестов парсинг аргументов командной строки, вынести всяческие константы путей, 
спрашивать хотим ли заново записывать тесты и т. д.
